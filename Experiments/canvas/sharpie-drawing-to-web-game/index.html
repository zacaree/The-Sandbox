<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sharpie Adventure</title>
  <style>
    * {
      box-sizing: border-box; 
      margin: 0; 
      line-height: 1.5;
    }
    body {
      padding: 20px;
      font-family: system-ui, -apple-system, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    main { 
      width: 800px;
      display: flex; 
      flex-direction: column; 
      gap: 10px;
    }
    ul { padding-left: 20px; }
    .canvas_wrap {
      position: relative;
    }
    canvas {
      width: 100%;
      border: 1px solid #000;
      border-radius: 6px;
    }
    input[type="file"] {
      position: absolute;
      top: 10px;
      left: 10px;
      color: transparent;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <main>
    <!-- <h1>Sharpie Adventure</h1>
    <ul>
      <li>Draw your own adventure (black sharpie on white paper works best).</li>
      <li>Then snap a photo and load it here to play!</li>
    </ul> -->
    <p id="bombCount"></p>
    <div class="canvas_wrap">
      <input type="file" id="imageInput" accept="image/*">
      <canvas id="outputCanvas"></canvas>
    </div>
  </main>

  <script>
    // Global variables
    const MAP_SIZE = 800;
    
    let mapData;
    let playerInitialPos = { x: 50, y: 50 };
    let player = { ...playerInitialPos, size: 10, speed: 7 };
    let bomb = { 
      x: 0, 
      y: 0, 
      size: 5,
      fuse: 2, 
      blastSize: 80,
      isPlaced: false,
      count: 3,
    };
    const itemBombs = {
      x: 200,
      y: 200,
      size: 5,
      count: 3,
    }
    
    // Global Elements
    const imageInput = document.getElementById('imageInput')
    const canvas = document.getElementById('outputCanvas');
    const bombCountEl = document.getElementById('bombCount');

    imageInput.addEventListener('change', handleImage);
    
    canvas.width = MAP_SIZE;
    canvas.height = MAP_SIZE;
    const ctx = canvas.getContext('2d');

    bombCountEl.innerText = `Bombs: ${bomb.count}`;
    
    function handleImage(event) {
      const input = event.target;
      if (input.files && input.files[0]) {
        const reader = new FileReader();

        reader.onload = function (e) {
          const img = new Image();
          img.src = e.target.result;

          img.onload = function () {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // Store map data
            mapData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

            // Define a set of 2 colors
            const grayscaleColors = [
              [0, 0, 0, 255],       // Black
              [255, 255, 255, 255], // White
            ];

            for (let i = 0; i < mapData.length; i += 4) {
              // Get lightness value of the current pixel
              const lightness = (mapData[i] + mapData[i + 1] + mapData[i + 2]) / 3;

              // Map lightness value to the index of the predefined colors
              const colorIndex = Math.floor(lightness / (255 / grayscaleColors.length));

              // if pixel is any shade of blue
              if (mapData[i] < 100 && mapData[i + 1] < 200 && mapData[i + 2] > 130) {
                console.log('Blue')
                // set itemBombs position to be the center of the blue pixel
                itemBombs.x = Math.floor((i / 4) % MAP_SIZE);
                itemBombs.y = Math.floor((i / 4) / MAP_SIZE);

                // set pixel to be white
                mapData[i] = 255;
                mapData[i + 1] = 255;
                mapData[i + 2] = 255;
                mapData[i + 3] = 255;
              } else {
                // Set new color values for each pixel based on lightness
                mapData[i] = grayscaleColors[colorIndex][0];
                mapData[i + 1] = grayscaleColors[colorIndex][1];
                mapData[i + 2] = grayscaleColors[colorIndex][2];
                mapData[i + 3] = grayscaleColors[colorIndex][3];
              }
            }

            // Render player
            renderMap();
            renderPlayer();
            renderItem();
          };
        };

        reader.readAsDataURL(input.files[0]);
      }
    }

    function renderMap() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.putImageData(new ImageData(mapData, canvas.width, canvas.height), 0, 0);
    }

    function renderPlayer() {
      ctx.fillStyle = 'mediumseagreen';
      ctx.fillRect(player.x, player.y, player.size, player.size);
    }

    function renderItem() {
      ctx.fillStyle = 'red';
      ctx.fillRect(itemBombs.x, itemBombs.y, itemBombs.size, itemBombs.size);
    }

    function renderBomb() {
      ctx.fillStyle = 'red';
      ctx.fillRect(bomb.x, bomb.y, bomb.size, bomb.size);
    }

    function explodeBomb() {
      bomb.isPlaced = false;

      // Calculate bomb explosion area
      const halfBlastSize = Math.floor(bomb.blastSize / 2);
      const explosionXArea = [...Array(bomb.blastSize)].map((_, i) => (bomb.x - halfBlastSize + i));
      const explosionYArea = [...Array(bomb.blastSize)].map((_, i) => (bomb.y - halfBlastSize + i) * MAP_SIZE);

      // Update map data
      explosionYArea.forEach((y) => {
        explosionXArea.forEach((x) => {
          const pixelInExplosion = (y + x) * 4;

          // if explosion pixel is touching player
          if (pixelInExplosion === (player.y * MAP_SIZE + player.x) * 4) {
            // reset player
            player.x = playerInitialPos.x;
            player.y = playerInitialPos.y;
          }

          mapData[pixelInExplosion] = 255;
          mapData[pixelInExplosion + 1] = 255;
          mapData[pixelInExplosion + 2] = 255;
          mapData[pixelInExplosion + 3] = 255;
        })
      })

      // Redraw the map and player
      renderMap();
      renderPlayer();
      renderItem();
    }

    function movePlayer(direction) {
      const dx = (direction === 'right') ? player.speed : (direction === 'left') ? -player.speed : 0;
      const dy = (direction === 'down') ? player.speed : (direction === 'up') ? -player.speed : 0;

      // Calculate next player position
      const nextXArea = [...Array(player.size)].map((_, i) => (player.x + i) + dx);
      const nextYArea = [...Array(player.size)].map((_, i) => ((player.y + i) + dy) * MAP_SIZE);

      let isWall = false;
      let isItem = false;

      // Check if the next position intersects with...
      nextYArea.forEach((y) => {
        nextXArea.forEach((x) => {
          const pixelInPlayer = (y + x) * 4;
          // a wall
          if (mapData[pixelInPlayer] === 0) {
            isWall = true;
          }
          // an item
          if (pixelInPlayer === (itemBombs.y * MAP_SIZE + itemBombs.x) * 4) {
            isItem = true;
          }
        })
      })

      if (isWall) { return; }

      // Update player position
      player.x += dx;
      player.y += dy;

      // Redraw the map and player
      renderMap();
      renderPlayer();
      renderItem();

      if (isItem) {
        bomb.count = bomb.count + itemBombs.count;
        bombCountEl.innerText = `Bombs: ${bomb.count}`;
        itemBombs.x = null;
        itemBombs.y = null;
        itemBombs.size = null;
        renderItem();
      }

      if (bomb.isPlaced) {
        renderBomb();
        setTimeout(() => explodeBomb(), bomb.fuse * 1000);
      }
    }

    function placeBomb() {
      bomb.x = player.x;
      bomb.y = player.y;
      bomb.isPlaced = true;
      bomb.count = bomb.count - 1;
      bombCountEl.innerText = `Bombs: ${bomb.count}`;

      // Redraw the map and player
      renderMap();
      renderPlayer();
      renderBomb();
      renderItem();
    }

    // Handle player movement with arrow keys
    document.addEventListener('keydown', function (event) {
      if (event.key === 'ArrowRight') movePlayer('right');
      else if (event.key === 'ArrowLeft') movePlayer('left');
      else if (event.key === 'ArrowDown') movePlayer('down');
      else if (event.key === 'ArrowUp') movePlayer('up');
      else if (event.key === 'b' && bomb.count !== 0) placeBomb();
    });
  </script>
</body>
</html>
